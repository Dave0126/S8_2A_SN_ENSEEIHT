## TD07: Sémantique et TDL : La machine TAM

#### 1. Adresse TAM

Une adresse TAM est de la forme d[r] où d est un entier relatif et r un nom de registre.

- SB : Bas de la pile. (栈底)
- ST : sommet de la pile. La donnée en sommet de pile est toujours en -1[ST]. (栈顶, 数据总为 -1[ST] )
- HB : le bas du tas. (堆底)
- HT : le haut du tas. La donnée au sommet du tas est toujours en -1[HT]. (堆顶, 数据总为 -1[HT])
- LB : pointe l’enregistrement d’activation courant. 
  - 0[LB] contient le lien statique (toujours 0 pour Microjava)
  - 1[LB] contient l’instruction exécutée au retour de la fonction et est affectée automatiquement par un CALL ou un CALLI.
  - 2[LB] contient l’ancienne valeur de LB (base de la fonction appelante) et est affectée automatiquement par un CALL ou un CALLI.
- CB : Bas du code
- CT : Haut du code
- CP : Instruction courante.

### Sémantique et TDL. : Generation de code

#### 1. Types simples et couple

##### 1.1 Traduire ce programme en langage assembleur pour la machine virtulle TAM en utilisant la position des identificateurs calculées dans la seance precedent.

我们可以将高级语言转换成*虚拟机可识别的通用汇编语言

```c
<int, int> c = {47,53};
const int test = 0;
```

```assembly
PUSH 2
LOADL 47
LODAL 53
STORE (2) 0[SB]
```

```c
int a = fst c;
```

```assembly
PUSH 1
LOAD (1) 0[SB]
POP (0) 1
STORE (1) 2[SB]
```

```assembly
PUSH 1
LOAD (2) 0[SB]
POP (1) 1
STORE (1) 3[SB]
```

```c
while(a * b != test) {
  // loop_body
}
```

```assembly
etiq_begin_while_1
  LOAD (1) 2[SB]
  LOAD (1) 3[SB]
  SUBR 1 MUL
  LOADL 0
  SUBR 1 NEQ
  JUMPIF (0) etiq_begin_while_1
  # LOOP_BODY
```

```c
// loop_body :
if (a > b) {
  // then_condition_1
  int na = a - b;
  a = na;
} else {
  // else_condition_1
  int nb = b - a;
  b = nb;
}
// end_condition_1
```

```assembly
LOAD (1) 2[SB]
LOAD (1) 3[SB]
SUBR IGTR
JUMPIF (0) etiq_else_condition
  ### then_condition_1
  PUSH 1
  LOAD (1) 2[SB]
  LOAD (1) 3[SB]
  SUBR 1 SUB
  STORE (1) 4[SB]
  LOAD (1) 4[SB]
  STORE (1) 2[SB]
  POP (0) 1
  ###
JUMP etiq_end_condition_1
# end_condition_1
```

##### 1.2 Proposer des actions sémantiques pour la generation de code.

```java
public String getCode() {
  String code;
  for (Instruction i : instruction) {
    code += i.getCode();
  }
  return code + "POP (0) " + this.getlength + "\n"); 
}
```



#### 2. Type enregistrement

Soit le programme :

```c
test{
  typedef struct Pointi { int x; int y;} Point;
  typedef struct Segmenti { Point ext1; Point ext2;} Segment;
  // ------------
  Segment s = {{0,1}, {2,3}};
  int x1 = s.ext1.x;
  int y2 = s.ext2.y;
  s.ext2.x = x1;
  s.ext1.y = y2;
}
```

```assembly
# ------------
PUSH 4
LOADL 0
LOADL 1
LOADL 2
LOADL 3
STORE(4) 0[SB]
# --- int x1 = s.ext1.x; ---
PUSH 1
LOAD (1) 0[SB]
STORE 1 4[SB]
# --- int y2 = s.ext2.y; ---
PUSH 1
LOAD (1) 3[SB]
STORE 1 5[SB]
# --- s.ext2.x = x1; ---
LOAD (1) 4[SB]
STORE 1 2[SB]
# --- s.ext1.y = y2; ---
LOAD (1) 5[SB]
STORE 1 1[SB]
# ------------
POP (0) 6
HALT
```



#### 3. Type tableau et pointeur

Soit le programme :

```c
test{
  int v = 1;
  int *ptr = &v;
  int j = *ptr;
  *ptr = 2;
  int t[] = new int[5];
  int i = t[3];
  t[3] = 4;
}
```

换成*虚拟机可识别的通用汇编语言

```assembly
# --- int v = 1; ---
PUSH 1
LOADL 1
STORE 1 0[SB]
# --- int *ptr = &v; ---
PUSH 1
LOADA 0[SB]
STORE (1) 1[SB]
# --- int j = *ptr; ---
PUSH 1
LOAD (1) 1[SB]
LOADI (1)
STORE (1) 2[SB]
# --- *ptr = 2; ---
LOADL 2
LOAD (1) 1[SB]
STOREI (1)
# --- int t[] = new int[5]; ---
PUSH 1
LOADL 5
LOADL 1
SUBR IMUL
SUBR MALLOC
STORE (1) 3[SB]
# --- int i = t[3]; ---
PUSH 1
LOAD (1) 3[SB]
LOADL 3
SUBR IMUL
SUBR IADD
LOADI (1)
STORE (1) 4[SB]
# --- int i = t[3]; ---
LOAD 4
LOAD (1) 3[SB]
LOADL 3
LOADL 1
SUBR IMUL
SUBR IADD
STOREI (1)
# --- t[3] = 4; ---
POP (0) 5
HALT
# ------------

```

